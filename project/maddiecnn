#!/usr/bin/env python
'''Identify my 4 dogs using CNN based on Keras.

Image dataset
-------------
    Image files are prefixed with the following convention:
    1) Each file name consists of:
    <Dog classifier code>_<5 digit sequence number>.jpg

    Dog classifier code contain 0 or any of the following classifiers:
    m: Maddie
    o: Olivia
    p: Pink
    a: Aimee

    Some examples:
    if a photo contains a picture of just Maddie, then the file name can be:
    m_00582.jpg

    if a photo contains a picture of both Maddie and Olivia, then the file name can be:
    mo_00582.jpg

    If a photo does not contain any of the dogs,
    _00582.jpg

Credit
------
    I am using a portion of the code from the CNN implementation in one of the Keras example files.
    Please see the license at the end of this docstring for their license terms.

Notes
-----
    1. Requirements to run this script.
        I am using virtualenv with Python 3.5.
    2. To view training on Tensorboard
       Invoke tensorboard by:
           tensorboard --logdir=<specify the directory is set to TENSORBOARD_LOG_DIR>
       Navigate to http://0.0.0.0:6006 in your browser.

To Do's
-------
    This file is still being updated.
    To-do items are:
    1. Test the accuracy flag.
    2. Change the Keras model to functional API.

Accuracy
--------
    Accuracy is to be verified.  Tentative unconfirmed accuracy (from Keras API output) is the following for a dataset
    of 2655 images in the training dataset:

    Training set accuracy: 0.8934
    Test accuracy: 0.8162650595228356

    Epochs was set to 400

    Accuracy number may go down upon verification via inspection of classification result so this is just for reference.

__author__ = "Hide Inada"
__copyright__ = "Copyright 2018, Hide Inada"
__license__ = "The MIT license"
__email__ = "hideyuki@gmail.com"

=========================================================================================
License and copyright statements for the portion of the source code taken from the Keras
mnist_cnn.py examples code
=========================================================================================
COPYRIGHT

All contributions by François Chollet:
Copyright (c) 2015 - 2018, François Chollet.
All rights reserved.

All contributions by Google:
Copyright (c) 2015 - 2018, Google, Inc.
All rights reserved.

All contributions by Microsoft:
Copyright (c) 2017 - 2018, Microsoft, Inc.
All rights reserved.

All other contributions:
Copyright (c) 2015 - 2018, the respective contributors.
All rights reserved.

Each contributor holds copyright over their respective contributions.
The project versioning (Git) records all such contribution source information.

LICENSE

The MIT License (MIT)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
=========================================================================================
End of Keras license
'''

from __future__ import print_function

import os
import sys
import logging
from pathlib import Path

from PIL import Image
import numpy as np
import random

import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import Flatten
from keras.layers import Conv2D
from keras.layers import MaxPooling2D
from keras.callbacks import TensorBoard

# Configurable parameters
DATASET_DIR = "../../dataset/256"
WEIGHT_FILE = "../../weight/maddiecnn.h5"
TENSORBOARD_LOG_DIR = "../../log"

MAX_NUM_FILES_TO_LOAD = -1  # Set to -1 for load all image files
IMAGE_WIDTH = 256
IMAGE_HEIGHT = IMAGE_WIDTH
IMAGE_CHANNELS = 3
NUM_CLASSES = 4
BATCH_SIZE = 128
NUM_EPOCHS = 400


class DogClassIndex:
    AIMEE = 0
    MADDIE = AIMEE + 1
    OLIVIA = MADDIE + 1
    PINK = OLIVIA + 1


class DogClassMarker:
    AIMEE = 'a'
    MADDIE = 'm'
    OLIVIA = 'o'
    PINK = 'p'


log = logging.getLogger(__name__)
logging.basicConfig(level=os.environ.get("LOGLEVEL", "DEBUG"))  # Change the 2nd arg to INFO to suppress debug logging


def load_image_data(test_data_ratio=0.2):
    """Load image files from the dataset directory

    Parameters
    ----------
    test_data_ratio: float
        Ratio of test data size in the total dataset size
    """
    dataset_path = Path(DATASET_DIR)
    log.debug("Loading data set from %s" % (dataset_path))

    image_list = list()
    image_class_list = list()

    files = list(dataset_path.glob("*.jpg"))
    num_files = len(files)
    log.debug("Number of image files found: %d" % (num_files))

    dataset_size = 0
    for i, f in enumerate(files):
        image_pil = Image.open(f)
        image_size = image_pil.size

        if image_size[0] != IMAGE_WIDTH:
            log.warning("Unexpected width %d for image file %s. Expecting: %d" % (image_size[0], f, IMAGE_WIDTH))
            continue

        if image_size[1] != IMAGE_HEIGHT:
            log.warning("Unexpected height %d for image file %s. Expecting: %d" % (image_size[1], f, IMAGE_HEIGHT))
            continue

        # Extract classes from the file name
        name = f.name
        underscore_pos = name.find("_")
        if underscore_pos < 0:
            log.warning("Invalid image file name. Missing classification marker for file %s" % (f))
            continue
        classes = name[0:underscore_pos]
        # log.debug("Classes: %s for file %s" % (classes, name))

        class_vector = np.zeros((NUM_CLASSES))
        if DogClassMarker.AIMEE in classes:
            class_vector[DogClassIndex.AIMEE] = 1.0
        if DogClassMarker.MADDIE in classes:
            class_vector[DogClassIndex.MADDIE] = 1.0
        if DogClassMarker.OLIVIA in classes:
            class_vector[DogClassIndex.OLIVIA] = 1.0
        if DogClassMarker.PINK in classes:
            class_vector[DogClassIndex.PINK] = 1.0
        # log.debug("Class vector %s" % (repr(class_vector)))

        data = np.array(image_pil)  # Convert from PIL image to numpy array
        image_list.append(data)
        image_class_list.append(class_vector)
        dataset_size = dataset_size + 1

        if i + 1 >= MAX_NUM_FILES_TO_LOAD and MAX_NUM_FILES_TO_LOAD != -1:
            break

    log.debug("Number of image files loaded: %d" % (dataset_size))

    training_dataset_size = int(dataset_size * (1 - test_data_ratio))
    test_dataset_size = dataset_size - training_dataset_size

    x = np.zeros((training_dataset_size, IMAGE_HEIGHT, IMAGE_WIDTH, 3), dtype='float32')
    y = np.zeros((training_dataset_size, NUM_CLASSES))

    x_test = np.zeros((test_dataset_size, IMAGE_HEIGHT, IMAGE_WIDTH, 3), dtype='float32')
    y_test = np.zeros((test_dataset_size, NUM_CLASSES))

    # Shuffle data
    random_index_array = list(range(dataset_size))
    random.shuffle(random_index_array)  # shuffle data inplace

    for i in range(training_dataset_size):
        single_image = image_list[random_index_array[i]]
        x[i] = single_image / 255
        y[i] = image_class_list[random_index_array[i]]

    for i in range(test_dataset_size):
        single_image = image_list[random_index_array[i + training_dataset_size]]
        x_test[i] = single_image / 255
        y_test[i] = image_class_list[random_index_array[i + training_dataset_size]]

    log.debug("Data loaded")
    return x, y, x_test, y_test


def cnn():
    """Convolutional Neural Network implementation"""
    x_train, y_train, x_test, y_test = load_image_data()

    input_shape = (IMAGE_HEIGHT, IMAGE_WIDTH, IMAGE_CHANNELS)

    model = Sequential()
    model.add(Conv2D(8, kernel_size=(7, 7), padding='same', activation='relu',
                     input_shape=input_shape))
    model.add(MaxPooling2D(pool_size=(2, 2)))  # To 128x128

    model.add(Conv2D(16, kernel_size=(5, 5), padding='same', activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))  # To 64x64

    model.add(Conv2D(32, kernel_size=(3, 3), padding='same', activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))  # To 32x32

    model.add(Conv2D(64, kernel_size=(3, 3), padding='same', activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))  # To 16x16

    model.add(Conv2D(128, kernel_size=(3, 3), padding='same', activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))  # To 8x8

    model.add(Dropout(0.25))
    model.add(Flatten())
    model.add(Dense(128, activation='relu'))
    model.add(Dropout(0.5))

    model.add(Dense(NUM_CLASSES, activation='sigmoid'))  # Do not use softmax as there are multiple valid labels

    model.compile(loss=keras.losses.binary_crossentropy,
                  optimizer=keras.optimizers.Adadelta(),
                  # metrics=['accuracy'])
                  metrics=['categorical_accuracy'])  # TODOS: I am still testing if this is a valid flag

    model.fit(x_train, y_train,
              batch_size=BATCH_SIZE,
              epochs=NUM_EPOCHS,
              verbose=1,
              validation_data=(x_test, y_test),
              callbacks=[TensorBoard(log_dir=TENSORBOARD_LOG_DIR)]
              )
    score = model.evaluate(x_test, y_test, verbose=0)
    print('Test loss:', score[0])
    print('Test accuracy:', score[1])

    # Save weight
    weight_path = Path(WEIGHT_FILE)
    if weight_path.parent.exists() is False:
        log.info("Not found weight directory %s. Creating." % (weight_path.parent))
        weight_path.parent.mkdir()

    model.save_weights(WEIGHT_FILE)

def main():
    cnn()


if __name__ == "__main__":
    main()
